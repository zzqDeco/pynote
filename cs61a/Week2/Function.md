从计算机硬件到上层软件，能够让这个过程和谐统一依赖于抽象。

正是因为抽象，我们才能够在甚至不了解周围抽象层任何原理的时候，处理当前抽象层的问题

同样的，任何编程语言都提供了一种语言层面的抽象，而语言内部也通过抽象降低代码的耦合度，也以这种方式进一步降低不同抽象层抽象空间的人交流的成本

函数就是一种很基本的抽象模式，它使得使用函数的人并不需要关心函数的内部原理，只需要知道函数的具体使用方式就能够将其带入工作之中

```python
def square(x):
	return mul(x,x)
```

python的函数自动重载，因为python是一个弱类型的语言（所以这语言是真几把垃圾，自动重载等于是增加代码运行风险，降低可读性，当你想要把别人的函数拿来用还要各种小心翼翼，尤其是那种不写注释的byd，简直就是sb中的sb）。为了了解python如何处理一个变量与内置函数同名，如果两个函数共享相同的名字这样的情况，我们需要了解environment这样的概念

An environment in which an expression is evaluated consists of a sequence of *frames*, depicted as boxes. Each frame contains *bindings*, each of which associates a name with its corresponding value.

对于变量或者常量，我们会 bindings 链接到具体内存中的值的空间。这很好理解，我们在对这样的 bound name 解析（evaluation，我不知道这中文应该叫什么）的时候，我们就是想要使用那样一个内存空间，读写它的值。

对于函数而言，我们处理 bindings 的方式更加复杂：对于函数而言，我们不仅像变量那样拥有一个在 environment 中的显式的 bound name 这样的名字，我们还拥有在深层的独属于每一个函数本身的一个 intrinsic name。虽然我们永远直接调用的都是 bound name，但是这样的名字并不能直接解析（evaluation），这样的名字如同一个指针，指向对于的函数的 intrinsic name，然后用 intrinsic name 去进行实际上的操作。值得注意的是，你可以在 environment 中创建大量的 bound name（你也许也可以叫做别名），但是对于一个实体存在的函数，只有一个 intrinsic name 与其对应。 

当你新创建一个函数的时候，会同时创建 bound name 与 intrinsic name 并会建立 bound name 指向 intrinsic name 然后 intrinsic name 永久 bind（捆绑）函数本体的关系

同时你也可以解绑这样的关系，让一个 bound name 绑定上另一个实体，无论其是函数，数值，还是一个对象

更重要的一点，bound name 的实际解析结果（evaluation）取决于他所指向的内容，Python并没有直接给这样的别名严格划分（这也是Python弱类型的体验），所以，当你不清晰的混用这样的东西的时候，你很容易出现自己难以发现的 Bug

这是一个很常见的例子：

```python
f = max
max = 3
result = f(2, 3, 4)
max(1, 2)  # Causes an error
```

是否 intrinsic name 就直接对应函数呢？在很多现代语言，包括 Python 中，这是否定的。我们不仅以函数名来区分我们的函数，我们还通过函数的参数（parameters）的数量和类型（Python的类型非常不明确，这点很蛋疼）来区分。intrinsic name 也只会对应到我们一类同名的函数组，我们再通过传入参数与函数名称（这些信息的总和叫做Function Signatures）准确定位到想要使用的函数。而对于一些特殊的函数，叫做内置函数，例如`max`这样的函数，可以接受任意数量的参数，无论接受多少的参数这样的内置函数都表现为`name(...)`，因为他们并没有被显式定义过，这样的函数过于特殊，作为Python解释器的一部分出现

environment（环境）在用户自定义函数中又是如何作用的呢？当调用某个自定函数时，我们将会创建新的域（frame），这个域（你可以看作）会在函数定义的那一帧创建一个域的分支，并且将函数的参数绑定到函数形式参数的名称上，所以对于当前的函数内的不仅包含当前内部的环境，还包括这个函数定义时那一帧的环境。我们又将环境分为多个 frame，我们在解析一个 name 的时候，我们会逐层向上找，找到的第一个与这个 name 绑定的在 environment 中的值拿来解析。我们找到了一个模型来解释我们的 name 将如何解析，但是这并不意味着任何实现，并不意味着解释器在实现的时候会真实的“寻找”，但这样的模型确实是准确的

另外一个原则在于，我们函数的功能并不受函数参数的 name 的影响，这样做的效果就是我们我们的参数在函数内部是局部的。实际上，这也是由于存在 frame 这样的机制决定的

函数的设计范式有其思想上的原因，其根本原因在于抽象。我们不仅有物理层，语言层，应用层之间的各种抽象，我们还有各种层次之间的抽象。虽然在CS中讨论的抽象只是现实抽象的一个子集，并不完全，但我们也不得不说，抽象不论以如何广泛或者狭窄，都有很多的普适意义：我们总是通过抽象，忽略不必要的细节，以一种更简单的方式来解决各种问题。在数学上，我们总是从泛性的角度抽象，我们尝试将不同的东西统一起来：而在CS上，我们总是从虚化的角度抽象，我们将已经明确的东西抽象为一个 tool，不再去关心这样的 tool 是怎样的（它的任何细节我们都不关心），我们只关心这样的 tool 能够提供给我们什么

我们可以用两个函数都来表达一个作用，在我们不考虑它们某些特性（如时空效率）的时候，他们就是完全等价的。在这种抽象概念上，任何相同效果的函数都是同样优秀的

Programming 上的函数之所以叫函数就是因为这种抽象使得这样的东西和数学意义上的函数非常相似：我们仅仅需要关心的东西在于这个函数的 domain，range 和 intent。然而这样的 intent 是如何实现的，我们并不关心，这个过程被抽象掉了

由此，尽管我们函数的权限有时候是极大的，但是我们更希望创建的是一个足够优秀的函数，对于函数的优秀的判定都是基于这个函数的抽象性质的：

1. 每个函数都应该只对应一个任务，如果一个函数可以划分成多个独立任务，那么就必须分为多个函数。通过这种方式可以使得函数得到简单的低耦合的抽象
2. 不应该有重复的代码，当你想要将一段代码复制使用的时候，你就要考虑复制的这部分是否可以抽象为新的函数
3. 函数应该一般地定义，使其具有普适性。但你考虑实现一个计算平方的函数时，就应该考虑是否一个计算任意次幂的函数更为合适

这些指导原则提高了代码的可读性，减少了错误的数量，并经常将编写的代码总量降至最低。把复杂的任务分解成简单的函数是一项需要经验才能掌握的技能

Python 和 Java一样拥有文档注释的注释形式，方面你去了解代码的每个部分是为了做什么的（不写文档注释的都是弱智）

同时在函数定义时，Python允许定义默认值，默认值是对于用户在函数调用时，如果没有指定这个数值，在接下来的过程中将会采用的值，这样的绑定可以实现一些简单的重载（我们总是喜欢重载，就是在于重载是对抽象的一个很好的体现）

[Python命名规范](https://peps.python.org/pep-0008/)